.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "tinyavrprogrammer" "7" "" "1.0.0" ""
.hy
.SH NAME
.PP
tinyavrprogrammer \[em] an AVRDUDE-compatible HVSP programming suite.
.SH SYNOPSIS
.PP
Consider moving your avrdude executable with tinyavroverride.
You can rename the original executable to _avrdude to retain non-HVSP
programming capability on other hardware.
\f[B]tiynavroverride\f[R] [\f[I]valid AVRDUDE program commands\f[R]] See
AVRDUDE(1) man page for more information.
.SH DESCRIPTION
.PP
This manual covers the software, hardware, and firmware aspects of the
programmer.
.PP
This man page may refer to the programmer as the \[lq]PROG\[rq] and to
the microcontroller being programmed as the \[lq]MCU\[rq].
The development machine and the firmware running on it might be reffered
to as the \[lq]PC\[rq].
.SS \f[B]tinyavrserver\f[R]
.PP
is a firmware library that contains an \f[B]AVRDUDE(1)\f[R]-compatible
command interpreter.
.PP
\f[I]main(targetchip:str)\f[R] is a high-level interface capable of
parsing \f[B]AVRDUDE(1)\f[R] commands.
However the library contains a series of lower-level abstrations that
can be used to implement a different higher-level interface.
.PP
\f[I]prog\f[R] is a class containing the state of the programmer along
with the functions required for low-level operation.
The initializer will look for a device that matches the device signature
and connect to it.
Any higher level wrapper (like the \f[I]main()\f[R] function should call
\f[I]release()\f[R] to deinitialize the usb connection.
.SS Write Operations
.PP
A typical write operation (as exemplified by upload_flash) should look
as follows:
.IP " 1." 4
Create a \f[I]prog\f[R] object.
.IP " 2." 4
Power on the MCU using \f[I]prog.cmd_power_on()\f[R].
.IP " 3." 4
Load MCU information using \f[I]prog.cmd_check()\f[R].
.IP " 4." 4
Erase the chip using \f[I]prog.cmd_chip_erase()\f[R].
.IP " 5." 4
Write the desired data into the programmer\[cq]s internal memory using
\f[I]prog.cmd_write_data(dest:int, data:bytes, len:int)->bytes\f[R].
Do note that this can only be done 60 bytes at a time.
.IP " 6." 4
Verify the data by generating a hash with \f[I]prog.cmd_hash_data(start,
end)\f[R] and then comparing it with the hash generated with
\f[I]hash(data: bytes)->bytes\f[R], which hashes given data with an
algorithm matching that of the programmer.
.IP " 7." 4
Write into the MCU (see the source code for a complete list of
operations).
.IP " 8." 4
Read back the data from the MCU into the programmer\[cq]s internal
memory (see the source code for a complete list of operations).
.IP " 9." 4
Repeat step 6.
.IP "10." 4
Power down the MCU with \f[I]prog.cmd_power_off()\f[R]
.IP "11." 4
Release the USB resources with \f[I]prog.release()\f[R]
.IP "12." 4
Ensure that the \f[I]prog\f[R] object is not used again.
.SS Read Operations
.PP
A typical read operation (as exemplified by read_flash) should look as
follows:
.IP "1." 3
Create a \f[I]prog\f[R] object.
.IP "2." 3
Power on the MCU using \f[I]prog.cmd_power_on()\f[R].
.IP "3." 3
Load MCU information using \f[I]prog.cmd_check()\f[R].
.IP "4." 3
Read the desired MCU data into the programmer\[cq]s internal memory.
(see the source code for a complete list of operations).
.IP "5." 3
Read from the programmer\[cq]s internal memory using
\f[I]prog.cmd_read_data(dest:int, len:int)->bytes\f[R].
Do note that this can only be done 60 bytes at a time.
.IP "6." 3
Verify the data by generating a hash with \f[I]prog.cmd_hash_data(start,
end)\f[R] and then comparing it with the hash generated with
\f[I]hash(data: bytes)\f[R], which hashes given data with an algorithm
matching that of the programmer.
.IP "7." 3
Power down the MCU with \f[I]prog.cmd_power_off()\f[R]
.IP "8." 3
Release the USB resources with \f[I]prog.release()\f[R]
.IP "9." 3
Ensure that the \f[I]prog\f[R] object is not used again.
.PP
All commands can result in assertion errors which should be handled
gracefully.
.PP
The library also contains a series of mid-level functions for operating
on flash and EEPROM as well as a few test functions used for testing.
.SS \f[B]tinyavroverride\f[R]
.PP
is a script using \f[B]tinyavrserver\f[R] that can pretend to be
\f[B]AVRDUDE(1)\f[R], and will even launch it if it\[cq]s asked to
program a chip not supported by \f[B]tinyavrprogrammer\f[R]
.PP
Consider moving your avrdude executable with tinyavroverride.
You can rename the original executable to _avrdude to retain non-HVSP
programming capability on other hardware.
.SS \f[B]tinyprogrammer\f[R]
.PP
is the software controlling the hardware portion of the programmer.
.PP
It\[cq]s a C++ program that incorporates both an usb-controlled
programming interface (core0) and a 250KHz boost-converter controller
and monitor (core1).
.PP
An excessive amount of effort has been put into ensuring safety of the
circuit, especially the boost converter.
The programmer will not allow any commands until both the boost voltage,
and the supply voltage are within specification.
If the specification (+ a large safety margin) are exceeded while the
MCU is on, an emergency shutdown will occur, requiring a manual power
reset to resume operation.
.PP
The programmer will shut off the MCU after a few seconds of inactivity.
This should never happen unless the firmware fails to shut it down.
.PP
See globals.hpp to see the programmer\[cq]s settings.
.SS Hardware
.PP
An RPI PICO based circuit diagram should be provided with the firmware.
The hardware uses a 250KHz boost-converter to generate the 12V required
to enter the HVSP mode.
See the BUGS section for the many issues with this design.
.PP
The circuit contains 6 different channels that have to be level-shifted.
The 5V MCU power is togged using an NPN+PNP trainsistor pair.
The 12V signal is isolated using an optoisolator.
The three PROG -> MCU lines are toggled using a single N-CHANNEL MOSFET
each.
The single MCU -> PROG line is isolated using an NPN transistor.
.PP
An RGB LED is provided to indicate various states of the programmer.
The RGB values used to generate the PWM signals driving it can be found
in globals.hpp.
.PP
By default, ADC channel 0 is used for reading the boost converter
voltage and channel 1 is used to read VBUS.
.PP
\f[B]WARNING:\f[R] globals.hpp contains calibration values for the ADC
(offset for each channel).
Those are based off of a single RPI PICO used in the programmer\[cq]s
development and might need to be revised.
.SS Pin mapping
.PP
The globals.hpp file of the tinyprogrammer contains all of the pin
constants
.IP \[bu] 2
\f[B]SCI\f[R] \[em] \f[I]PIN 17\f[R] \[em] Serial clock input
.IP \[bu] 2
\f[B]SDI\f[R] \[em] \f[I]PIN 15\f[R] \[em] Serial data input
.IP \[bu] 2
\f[B]SII\f[R] \[em] \f[I]PIN 14\f[R] \[em] Serial instruction input
.IP \[bu] 2
\f[B]SDO\f[R] \[em] \f[I]PIN 12\f[R] \[em] Serial data output
.IP \[bu] 2
\f[B]POWER\f[R] \[em]\ \f[I]PIN 16\f[R] \[em] toggles power to the MCU
.IP \[bu] 2
\f[B]PULSE\f[R] \[em]\ \f[I]PIN 13\f[R] \[em] the pwm source that drives
the boost converter
.IP \[bu] 2
\f[B]HIGHVOLT\f[R] \[em]\ \f[I]PIN 18\f[R] \[em] toggles the connection
between 12V line and the MCU\[cq]s reset pin.
.IP \[bu] 2
\f[B]RED\f[R] \[em]\ \f[I]PIN 9\f[R] \[em] the red PWM channel of the
RGB LED indicator.
.IP \[bu] 2
\f[B]GREEN\f[R] \[em]\ \f[I]PIN 8\f[R] \[em] the green PWM channel of
the RGB LED indicator.
.IP \[bu] 2
\f[B]BLUE\f[R] \[em]\ \f[I]PIN 7\f[R] \[em] the blue PWM channel of the
RGB LED indicator.
.SS Communication Protocol
.PP
The firmware communicates with the programmer over USB, the packet size
is 64 bytes, however this could probably be extended.
The programmer has a 128kB buffer that it uses to store intermediate
data.
.PP
The first byte of a PC -> PROG packet contains a commandID, the second
contains the size of the package.
The remaining 62 bytes may contain command data.
.PP
The first byte of a PROG -> PC packet contains a result compatible with
the Responses enum.
Any response other than 1 is an error and will result in an assertion
failure.
.PP
All writes to the PROG should be followed by a read and check.
No errors should go ignored.
All logic and cmd errors can be recovered from, hardware errors should
result in the program terminating after sending appropriate power-off
commands to the MCU (if relevant) and releasing the USB context.
.SS Supported Microcontrollers
.PP
The following microcontrollers are currently supported.
The support can be easily extended to other microcontrollers, as
discussed later.
.IP \[bu] 2
\f[B]ATTiny85\f[R]
.IP \[bu] 2
\f[B]ATTiny45\f[R]
.IP \[bu] 2
\f[B]ATTiny25\f[R]
.SS Extending support
.SS - \f[B]tinyavroverride.py\f[R]
.PP
\f[I]chips\f[R] contains the list of matches that determines whether to
use tinyavrserver.
See AVRDUDE(1) for chip identifiers.
.SS - \f[B]tinyprogrammer/globals.hpp\f[R]
.PP
the \f[I]CHIP_ID\f[R] enum contains the IDs of the supported MCUs.
.PP
\f[I]info\f[R] contains the MCU information in the following format:
.IP "1." 3
\f[I]strname\f[R] \[em] the name used by the firmware in its output
messages.
.IP "2." 3
\f[I]id\f[R] \[em]\ the CHIP_ID associated with the MCU.
.IP "3." 3
\f[I]signature\f[R] \[em]\ the 3-byte signature.
See the documentation for the relevant MCU.
.IP "4." 3
\f[I]word_bytes\f[R] \[em]\ the number of bytes per word, typically 2.
.IP "5." 3
\f[I]flash_words\f[R] \[em]\ number of words of flash.
See the documentation for the relevant MCU.
.IP "6." 3
\f[I]flash_page_Words\f[R] \[em]\ number of flash words per page.
.IP "7." 3
\f[I]eeprom_page_bytes\f[R]\ \[em]\ number of EEPROM bytes per page.
.IP "8." 3
\f[I]eeprom_page_num\f[R] \[em] number of EEPROM pages.
.SH EXAMPLES
.PP
On ATTiny85: Set fuses to 0xE2 and 0x56, flash firmware.hex.
\f[B]tinyavroverride.py\f[R] -p t85 -Ulfuse:w:0xE2:m -Uhfuse:w:0x56:m
-Uflash:w:firmware.hex:i See \f[B]AVRDUDE(1)\f[R] for a comprehensible
breakdown of available commands.
.SH BUGS
.PP
The way the programmer handles reading fuses does not account for MCUs
that have less or more than 3.
This should work fine with the ATTinyx5 and ATtinyx4 series, but might
be an issue with some of the older ATTiny MCUs.
This shouldn\[cq]t require much effort to fix if it does become an
issue.
.SH CAVEATS
.SS Software
.PP
The way the programmer handles reading fuses does not account for MCUs
that have less or more than 3.
This should work fine with the ATTinyx5 and ATtinyx4 series, but might
be an issue with some of the older ATTiny MCUs.
This shouldn\[cq]t require much effort to fix if it does become an
issue.
.PP
The programmer can only read/write up to 128kB of data at a time.
The firmware does not account for the possibility of a larger operation.
There are currently no HVSP microcontrollers that would require a
greater amount of RAM.
.PP
The hash function used for verifying data is weak, it\[cq]s a simple
series XORs.
.PP
The USB packet size (64B) is needlessly small.
.PP
The HVSP protocol is implemented through bitbanging.
This could be replaced with PIO.
.SS Hardware
.PP
The boost-converter design is flawed and incapable of supplying more
than \[ti]30mA.
This is more than enough for the protocol.
One relatively simple improvement would involve replacing the switching
NPN transistor with a MOSFET and increasing the operating frequency.
.PP
I would be much simpler to use opto-isolation for all channels instead
of using 3 different methods.
.SH LICENSE
.PP
This manual, as well as all of the tinyavrprogrammer components
described here
.SH SEE ALSO
.PP
\f[B]AVRDUDE(1)\f[R]
